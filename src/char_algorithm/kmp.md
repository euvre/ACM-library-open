# KMP算法

## 定义

### $T$ 与 $P$

$T$ 表示被匹配的字符串，即 **文本串** ；$P$ 表示需要匹配的字符串，即 **模式串** 。

### $nxt$ 数组

$nxt[i]$ 表示“ $P$ 中以 $i$ 结尾的非前缀字符串” 与” $P$ 的前缀“能够匹配的最大长度。

### $f$ 数组

$f[i]$ 表示” $T$ 中以 $i$ 结尾的子串“与” $P$ 的前缀“所能匹配的最大长度。

## 实现

### $nxt$ 数组

#### $O(n^2)$ 实现（朴素）

略

#### $O(n)$ 实现

>引理：
>- 若 $j_0$ 为 $nxt[i]$ 的”候选项“，则小于 $j_0$ 的最大的 $nxt[i]$ ”候选项“为 $nxt[j_0]$。
>- ”候选项“：若 $j$ 是 $nxt[i]$ 的”候选项“，则有 $P[1 \sim j]=P[i-j+1 \sim i]$
>
>证明：反证法。略。

考虑 $P="abababaac"$ 的情景。若已求出
$$nxt[0]=0,nxt[1]=0,nxt[2]=1,nxt[3]=2,nxt[4]=3,nxt[5]=4。$$

现在需要求出 $nxt[6]$ 。已知 $P[6]=P[4]='a'$ ，所以可以继续匹配，$nxt[6]=5$ 。

接下来求 $nxt[7]$ 。已知 $P[7] \neq P[5]$ ，所以匹配失败，不能把匹配匹配长度从 $5$ 增长到 $6$ 。我们只有减短匹配长度。根据引理， 以 $i=6$ 为结尾的匹配长度除了$j_0=nxt[6]=5$ 以外，还有 $j_1=nxt[j_0]=nxt[5]=4$ 、$j_2=nxt[j_1]=nxt[4]=3$ 等。我们尝试 $P[7]$ 与 $P[4]$ 、$P[7]$ 与 $P[3]$ 的延展是否可行。

然而，$P[7] \neq P[4]$ , $P[7] \neq P[3]$ ，无法延展。所以我们只能让 $P[7]$ 从头开始匹配。因为 $P[7]=P[1]$ ，即 $nxt[7]=1$ 。

~~~cpp
// nxt[0] = 0;
for (int i = 1, j = 0; i <= P_len - 1; ++i) {
    while (j > 0 && P[i] != P[j]) {
        j = nxt[j - 1];
    }
    if (P[i] == P[j]) {
        ++j;
    }
    nxt[i] = j;
}
~~~

灵感来自于《算法竞赛进阶指南》。